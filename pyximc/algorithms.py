import numpy as np
import scipy.integrate as spi

def op_algorithm(
    theta_r: float,
    omega_r: float,
    theta_m: float,
    omega_m: float,
    t: np.ndarray,
    kp: float = 3.6,
    kd: float = 0.028,
    ki: float = 0.0001,
):
    """
    Motor operation algorithm.

    Parameters
    ----------
    theta_r : float
        The desired rotor position (rad), the value of which is generated by the speed profile generator.
    omega_r : float
        The angular speed of rotation of the rotor (rad/s), 
        the value of which is generated by the speed profile generator.
    theta_m : float
        The rotor position (rad) calculated using the rotor position estimation.
    omega_m : float
        The speed of rotation of the rotor (rad/c) calculated using the rotor position estimation.
    kp : float
        Target position.
    kd : float
        Revolution per second.
    ki : float
        Rpm.
    """
    angle_error = theta_r - theta_m
    speed_error = omega_r - omega_m

    return kp*angle_error + kd*speed_error + ki*spi.trapz(angle_error, t)

def calc_rotor_flux_linkage(
    n: int,
    k: float = None,
    t: float = None,
    i: float = None,
):
    """
    Calculate the rotor flux linkage.

    Parameters
    ----------
    k : float
        This can either be the motor's electromechnical coefficient (km) or the counter-EMF coefficient (kemf).
    n : int
        Number of steps per revolution.
    t : float
        Holding torque (Hm).
    i : float
        The rated current (nominal current [A]).
    """
    if k is not None:
        return 4*k/n
    return 4*t/(n*i)
    